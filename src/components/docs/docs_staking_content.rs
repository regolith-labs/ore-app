
use dioxus::prelude::*;
use ore_boost_api::state::Boost;
use steel::Pubkey;

use crate::{
    components::*,
    gateway::GatewayResult,
    hooks::{use_all_boosts, use_boost_config_wss},
};

use super::*;

pub fn StakingContent() -> Element {
    rsx! {
        ContentSection {
            StakingIntro {}
            StakingHowItWorks {}
            // StakingGeneratingYield {}
            StakingFaq {}
        }
    }
}

fn StakingIntro() -> Element {
    rsx! {
        span {
            span {
                class: "font-semibold text-elements-highEmphasis",
                "Staking offers yield to liquidity providers for making markets more efficient for traders. "
            }
            "These incentives help offset the risk that liquidity providers inherently take on by creating better markets."
        }
    }
}

fn StakingHowItWorks() -> Element {
    rsx! {
        SectionTitle {
            "How it works"
        }
        BulletPointList {
            BulletPoint {
                "Boosts are a feature which allow the ORE governance community to fund growth initiatives such as marketing, development, and liquidity using protocol emissions."
            }
            BulletPoint {
                "Yield is generated by automatically provisioning a slice of supply to the \"boost budget\". These funds come from the existing token emissions schedule, and do not produce any additional inflation for holders."
            }
            BulletPoint {
                "A number of the currently active boosts are directed towards liquidity incentives to help bootstrap liquidity for the token. LPs can earn yield by making ORE markets more efficient for traders."
            }
        }
    }
}

fn _StakingGeneratingYield() -> Element {
    let boost_config = use_boost_config_wss();
    let boosts = use_all_boosts();

    let total_weight = use_memo(move || {
        let mut total_weight = 0;
        if let Ok(boost_config) = boost_config.cloned() {
            total_weight = boost_config.total_weight;
        }
        total_weight
    });

    let take_rate = use_memo(move || {
        if let Ok(boost_config) = boost_config.cloned() {
            boost_config.take_rate
        } else {
            0
        }
    });

    let sorted_boosts = use_memo(move || {
        let mut boost_vec: Vec<(Pubkey, Signal<GatewayResult<Boost>>)> = boosts
            .iter()
            .filter(|(_, boost_signal)| {
                if let Ok(boost) = boost_signal.cloned() {
                    boost.weight > 0
                } else {
                    false
                }
            })
            .map(|(k, v)| (*k, *v))
            .collect();

        boost_vec.sort_by(|a, b| {
            let weight_a = a.1.cloned().map(|boost| boost.weight).unwrap_or(0);
            let weight_b = b.1.cloned().map(|boost| boost.weight).unwrap_or(0);
            weight_b.cmp(&weight_a)
        });

        boost_vec
    });

    rsx! {
        SectionTitle {
            "Boost budget"
        }
        span {
            class: "pb-4",
            // span {
            //     class: "font-semibold text-elements-highEmphasis",
            //     "Staking offers yield to liquidity providers for making markets more efficient for traders. "
            // }
            "Currently, {(*take_rate.read() as f64 / ore_boost_api::consts::DENOMINATOR_BPS as f64 * 100.0) as u64}% of emissions are allocated towards boost initiatives. Use the interactive graph below to analyze the budget and explore where this yield is going."
        }
        StakingBoostBudget {
            take_rate: take_rate.clone(),
            sorted_boosts: sorted_boosts.clone(),
            total_weight: total_weight.clone(),
        }
    }
}

#[component]
fn StakingBoostBudget(
    take_rate: Memo<u64>,
    sorted_boosts: Memo<Vec<(Pubkey, Signal<GatewayResult<Boost>>)>>,
    total_weight: Memo<u64>,
) -> Element {
    let mut selected_item = use_signal::<Option<Pubkey>>(|| None);

    let miner_take_rate_width = use_memo(move || {
        let percentage = 100.0
            - (*take_rate.read() as f64 / ore_boost_api::consts::DENOMINATOR_BPS as f64) * 100.0;
        format!("{}%", percentage)
    });

    rsx! {
        Col {
            gap: 4,
            Row {
                class: "w-full h-16 flex flex-row  overflow-hidden",
                button {
                    class: "h-12 hover:h-16 mb-auto bg-white opacity-20 shrink-0 transition-all duration-300",
                    style: "width: {miner_take_rate_width};",
                    onclick: move |_| {
                        selected_item.set(None);
                    }
                }
                div {
                    class: "flex flex-row w-full",
                    for (i, boost_ref) in sorted_boosts.iter().enumerate() {
                        StakingBoostYield {
                            i: i,
                            selected_item: selected_item.clone(),
                            boost_addr: boost_ref.0.clone(),
                            boost_signal: boost_ref.1.clone(),
                            total_weight: total_weight.clone(),
                        }
                    }
                }
            }
            if let Some(_selected_item) = *selected_item.read() {
                StakingBudgetBreakdown {
                    title: "Miners".to_string(),
                    description: "Miners compete to earn rewards by expending hashpower, consuming energy and computational resources. This helps tie ORE to the physical economy, and allows miners to convert electricity into liquid financial capital.".to_string(),
                    allocation: "50".to_string(),
                    emissions: "720".to_string(),
                }
            } else {
                StakingBudgetBreakdown {
                    title: "Miners".to_string(),
                    description: "Miners compete to earn rewards by expending hashpower, consuming energy and computational resources. This helps tie ORE to the physical economy, and allows miners to convert electricity into liquid financial capital.".to_string(),
                    allocation: "50".to_string(),
                    emissions: "720".to_string(),
                }
            }
        }
    }
}

#[component]
fn StakingBudgetBreakdown(
    title: String,
    description: String,
    allocation: String,
    emissions: String,
) -> Element {
    rsx! {
        Col {
            span {
                class: "text-elements-highEmphasis font-semibold",
                "{title}"
            }
            span {
                class: "pt-2",
                "{description}"
            }
            Row {
                class: "justify-between w-full text-base pt-4",
                span {
                    class: "font-medium text-elements-lowEmphasis",
                    "Allocation"
                }
                span {
                    class: "font-medium text-elements-highEmphasis",
                    "{allocation}%"
                }
            }
            Row {
                class: "justify-between w-full text-base pt-4",
                span {
                    class: "font-medium text-elements-lowEmphasis",
                    "Emissions"
                }
                span {
                    class: "font-medium text-elements-highEmphasis",
                    "{emissions} ORE / day"
                }
            }
        }
    }
}

#[component]
fn StakingBoostYield(
    i: usize,
    boost_addr: Pubkey,
    boost_signal: Signal<GatewayResult<Boost>>,
    total_weight: Memo<u64>,
    selected_item: Signal<Option<Pubkey>>,
) -> Element {
    let width = use_memo(move || {
        if let (Ok(boost), total) = (boost_signal.cloned(), *total_weight.read()) {
            if total > 0 {
                let percentage = (boost.weight as f64 / total as f64) * 100.0;
                format!("{}%", percentage)
            } else {
                "0%".to_string()
            }
        } else {
            "0%".to_string()
        }
    });

    let opacity = use_memo(move || format!("{}", (100 - (i * 20)) as f64 / 100.0));

    rsx! {
        button {
            class: "w-full h-12 hover:h-16 mb-auto bg-elements-gold transition-all duration-300",
            style: "width: {width}; opacity: {opacity};",
            onclick: move |_| {
                selected_item.set(Some(boost_addr));
            }
        }
    }
}

fn StakingFaq() -> Element {
    rsx! {
        SectionTitle {
            "FAQ"
        }
        Col {
            class: "md:flex-row w-full h-min mx-auto max-w-7xl justify-start",
            Col {
                class: "w-full h-min justify-start",
                FaqItem {
                    question: "Will there be more boosts?",
                    "Yes, the ORE community is actively involved in proposing and managing boost incentives. "
                    Link {
                        new_tab: true,
                        to: "https://discord.gg/4TQfshAAsT",
                        span { class: "text-elements-gold hover:underline font-medium", "Join the Discord" }
                    }
                    " to stay up to date and get involved in the ORE boost governance process."
                }
                FaqItem {
                    question: "Why does the APR change?",
                    "APR is calculated based on a 7-day rolling average. As more assets are staked in a boost, the yield is split among more participants, causing the APR to decrease. Conversely, if the total staked amount goes down, the APR will rise.",
                }
                FaqItem {
                    question: "Are there risks to providing liquidity?",
                    "Yes, providing liquidity comes with inherent financial risk, including but not limited to divergence loss. Divergence loss occurs when the relative price of deposited tokens changes, potentially reducing the value of the deposit compared to simply holding the tokens separately. Once deposited, your exposure to each token may change depending on market conditions."
                }
            }
        }
    }
}
